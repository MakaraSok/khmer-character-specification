#!/usr/bin/python3
# Copyright (c) 2021-2022, SIL International.
# Licensed under MIT license: https://opensource.org/licenses/MIT

import enum, re

class Cats(enum.Enum):
    Other = 0; Base = 1; Robat = 2; Coeng = 3; ZFCoeng =4
    Shift = 5; Z = 6; VPre = 7; Vowel = 8; VPost = 9
    MS = 10; MF = 11

categories =  ([Cats.Base] * 52     # 1780-17B3
            + [Cats.Vowel] * 2      # 17B4-17C5
            + [Cats.VPost]          # 17B6
            + [Cats.Vowel] * 10     # 17B7-17C0
            + [Cats.VPre] * 3       # 17C1-17C3
            + [Cats.VPost] * 2      # 17C4-17C5
            + [Cats.MS]             # 17C6
            + [Cats.MF] * 2         # 17C7-17C8
            + [Cats.Shift] * 2      # 17C9-17CA
            + [Cats.MS]             # 17CB
            + [Cats.Robat]          # 17CC
            + [Cats.MS] * 5         # 17CD-17D1
            + [Cats.Coeng]          # 17D2
            + [Cats.MS]             # 17D3
            + [Cats.Other] * 9      # 17D4-17DC
            + [Cats.MS])            # 17DD

khres = {   # useful regular sub expressions used later
    "B":       "[\u1780-\u17B3]",
    "SCF":     "[\u1780-\u1799\u179B-\u17B3]",
    "SNB":     "[\u1780-\u1793\u1795-\u17A2]",
    "S1":      "[\u1780-\u1783\u1785-\u1788\u178A-\u178D\u178F-\u1792"
               "\u1795-\u1797\u179E-\u17A0\u17A2]",
    "S2":      "[\u1784\u1780\u178E\u1793\u1794\u1798-\u179D\u17A1\u17A3-\u17B3]",
    "VA":      "[\u17C1-\u17C3]?[\u17B7-\u17BA\u17BE\u17D0\u17DD]|\u17B6\u17C6",
    "VB":      "[\u17C1-\u17C3][\u17BB-\u17BD]",
    # contains series 1 and no BA
    "STRONG":  "{S1}\u17CC?(?:\u17D2{SNB})?(?:\u17D2{SCF}\u200D|\u17D2{SNB})?|"
               "{SNB}\u17CC?(?:\u17D2{S1}(?:\u17D2{SCF}\u200D|\u17D2{SNB})?"
               "|\u17D2{SNB}\u17D2{S1})",
    # contains BA or only series 2
    "NSTRONG": "\u1794\u17CC?(?:\u17D2{B}(?:\u17D2{B})?)?\u200D?|"
               "{S2}\u17CC?(?:\u17D2{S2})?(?:(?:\u17D2{S2})?(?:\u17D2{B}\u200D)?)|"
               "{B}\u17CC?(?:(?:\u17D2{B})(?:\u17D2\u1794)|"
               "(?:\u17D2\u1794)(?:\u17D2{B}\u200D?)?)",
    # final right spacing coeng
    "COENGR":  "[\u17C9\u17CA]?(?:[\u17C9\u17CA]\u200C?)?(?:{VA}|{VB})",
    # final all coengs
    "COENGF":  "[\u17C9\u17CA]?(?:[\u17C9\u17CA]\u200C?)?(?:{VA}|{VB})?"
               "[\u17B6\u17BF\u17C0\u17C4\u17C5]",
    "COENGS":  "(?:(?:\u17D2{SCF})?\u17D2{B}|"
               "(?:(?:\u17D2[\u1783\u1788\u178D\u1794\u1799\u179F]\u200D(?={COENGR}))|"
               "(?:\u17D2{SCF}\u200D(?={COENGF}))))",
    "SHIFT":   "(?:(?<={STRONG})[\u17C9\u17CA]?\u17CA\u200C(?=VA)|"
               "(?<={NSTRONG})[\u17C9\u17CA]?\u17C9\u200C(?={VA}|[\u17D0\u17DD])|"
               "[\u17C9\u17CA](?:[\u17C9\u17CA])?)",
    "V":       "(?:\u17C1[\u17B7-\u17BD]?|[\u17C2\u17C3][\u17B7-\u17BD]?\u17B6?|"
               "[\u17B7-\u17BD][\u17B6\u17C4\u17C5]|[\u17B4-\u17C5])",
    "MS":      "(?:[\u17C6\u17CB\u17CD-\u17CF\u17D1\u17D3]|"
               "(?<!\u17BB[\u17B6\u17C4\u17C5]?)[\u17D0\u17DD]|"
               "[\u17C6\u17CB\u17CD-\u17D1\u17D3\u17DD])"
}

# expand 2 times: CEONGS -> COENGF -> VA
for i in range(2):
    khres = {k: v.format(**khres) for k, v in khres.items()}

def charcat(c):
    ''' Returns the Khmer character category for a single char string'''
    o = ord(c)
    if 0x1780 <= o <= 0x17DD:
        return categories[o-0x1780]
    elif o == 0x200C:
        return Cats.Z
    elif o == 0x200D:
        return Cats.ZFCoeng
    return Cats.Other

def khnormal(txt, lang="km"):
    ''' Returns khmer normalised string, without fixing or marking errors'''
    # categorise every character in the string
    charcats = [charcat(c) for c in txt]

    # Recategorise base -> coeng after coeng char
    for i in range(len(charcats)-1, 0, -1):
        if charcats[i-1] == Cats.Coeng and charcats[i] == Cats.Base:
            charcats[i] = Cats.Coeng

    # find subranges of base+non other and sort components in the subrange
    i = 0
    res = []
    while i < len(charcats):
        c = charcats[i]
        if c != Cats.Base:
            res.append(txt[i])
            i += 1
            continue
        # scan for end of syllable
        j = i + 1
        while j < len(charcats) and charcats[j].value > Cats.Base.value:
            j += 1
        # sort syllable based on character categories
        # sort the char indices by category then position in string
        newindices = sorted(range(i, j), key=lambda e:(charcats[e].value, e))
        replaces = "".join(txt[n] for n in newindices)

        replaces = re.sub("([\u17D2\u200C\u200D])[\u17D2\u200C\u200D]+", r"\1", replaces)
        replaces = re.sub("\u17C1(\u17BB?)\u17B8", "\\1\u17BE", replaces)
        replaces = re.sub("\u17C1(\u17BB?)\u17B6", "\\1\u17C4", replaces)
        replaces = re.sub("\u17B8(\u17BB?)\u17C1", "\\1\u17BE", replaces)
        replaces = re.sub("\u17B6(\u17BB?)\u17C1", "\\1\u17C4", replaces)
        replaces = re.sub("({VA})(\u17BB)".format(**khres), r"\2\1", replaces)
        # replace -u + upper vowel with consonant shifter
        replaces = re.sub("({STRONG}[\u17C9\u17CA]?)\u17BB(?={VA})".format(**khres),
                          "\\1\u17CA", replaces)
        replaces = re.sub("({NSTRONG}[\u17C9\u17CA]?)\u17BB(?={VA})".format(**khres),
                          "\\1\u17C9", replaces)
        replaces = re.sub("(\u17D2\u179A)(\u17D2[\u1780-\u17B3](?!\u200D))",
                          r"\2\1\u200D" if lang.lower()=="tpu" else r"\2\1", replaces)
        replaces = re.sub("(\u17D2)\u178A", "\\1\u178F", replaces)
        res.append(replaces)
        i = j
    return "".join(res)

def khtest(txt):
    ''' Tests normalized text for conformance to Khmer encoding structure '''
    import regex
    syl = ("{B}\u17CC?{COENGS}?{SHIFT}?{V}?{MS}?|[\u17C7\u17C8]|"
           "[\u17D4-\u17DC\u17E0-\u17F9\u19E0-\u19FF]|"
           "[^\u1780-\u17F9\u19E0-\u19FF]").format(**khres)
    res = regex.match(r"^({})+$".format(syl), txt)
    return res != None

if __name__ == "__main__":
    import argparse, sys

    parser = argparse.ArgumentParser()
    parser.add_argument("infile",nargs="+",help="input file")
    parser.add_argument("-o","--outfile", help="Output file")
    parser.add_argument("-u","--unicodes",action="store_true")
    parser.add_argument("-f","--fail",action="store_true",
                        help="Only print lines that fail the regex after normalising")
    parser.add_argument("-l","--lang",default="km","Language specific processing")
    args = parser.parse_args()

    if args.unicodes:
        instr = "".join(chr(int(x, 16)) for x in args.infile)
        res = khnormal(instr, lang=args.lang)
        if not args.fail or not khtest(res):
            print(" ".join("{:04X}".format(ord(x)) for x in res))
    else:
        infile = open(args.infile[0], encoding="utf-8")
        outfile = open(args.outfile, "w", encoding="utf-8") if args.outfile else sys.stdout
        for l in infile.readlines():
            res = khnormal(l, lang=args.lang)
            if not args.fail or not khtest(res):
                outfile.write(res)
